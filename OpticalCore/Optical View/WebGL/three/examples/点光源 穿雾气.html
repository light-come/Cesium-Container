<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style type="text/css">
        html, body {
            margin: 0;
			width:100%;
			height:100%;
			margin: 0;
			padding: 0;
			overflow: hidden;
			max-width: 100%;
			max-height: 100%;
			-webkit-font-smoothing: antialiased;
        }

        canvas {
            display: block;
        }

    </style>
</head>
<body>
	<div id="container" tabindex="0" style="width: 100%;height: 100%;"></div>
</body>
<script src="/build/three.js"></script>
<!-- <script src="/build/three.module.js"></script> -->
<script src="../examples/js/controls/OrbitControls.js"></script>
<script src="../examples/js/libs/stats.min.js"></script>
<script src="../examples/js/libs/dat.gui.min.js"></script>

<script>
    var camera, scene, renderer;
	var material;
	var uniforms;

	function init() {
		var a = `
		varying vec2 vUv;
		uniform vec3      iResolution;           // 视口分辨率（像素）
		uniform float     iTime;                 // 着色器播放时间（秒）
		void main(){
			// Normalized pixel coordinates (from 0 to 1)
			// vec2 uv = fragCoord/iResolution.xy;

			// Time varying pixel color
			//vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));
			vec3 col = 0.5 + 0.5*cos(iTime+vUv.xyx+vec3(0,2,4));
			// Output to screen
			gl_FragColor = vec4(col,1.0);
		}
		`
		const fragmentShader = `
			varying vec2 vUv;


			// 时间
			uniform float iTime;
			// 分辨率
			uniform vec2 iResolution;
			// 鼠标位置
			uniform vec2 iMouse;

			uniform sampler2D iChannel0;
			
			#define D_DEMO_FREE


			#ifdef D_DEMO_FREE
				// Apply noise on top of the height fog?
				#define D_FOG_NOISE 1.0

				// Height fog multiplier to show off improvement with new integration formula
				#define D_STRONG_FOG 0.0

				// Enable/disable volumetric shadow (single scattering shadow)
				#define D_VOLUME_SHADOW_ENABLE 1

				// Use imporved scattering?
				// In this mode it is full screen and can be toggle on/off.
				#define D_USE_IMPROVE_INTEGRATION 1

			//
			// Pre defined setup to show benefit of the new integration. Use D_DEMO_FREE to play with parameters
			//
			#elif defined(D_DEMO_SHOW_IMPROVEMENT_FLAT)
				#define D_STRONG_FOG 10.0
				#define D_FOG_NOISE 0.0
				#define D_VOLUME_SHADOW_ENABLE 1
			#elif defined(D_DEMO_SHOW_IMPROVEMENT_NOISE)
				#define D_STRONG_FOG 5.0
				#define D_FOG_NOISE 1.0
				#define D_VOLUME_SHADOW_ENABLE 1
			#elif defined(D_DEMO_SHOW_IMPROVEMENT_FLAT_NOVOLUMETRICSHADOW)
				#define D_STRONG_FOG 10.0
				#define D_FOG_NOISE 0.0
				#define D_VOLUME_SHADOW_ENABLE 0
			#elif defined(D_DEMO_SHOW_IMPROVEMENT_NOISE_NOVOLUMETRICSHADOW)
				#define D_STRONG_FOG 3.0
				#define D_FOG_NOISE 1.0
				#define D_VOLUME_SHADOW_ENABLE 0
			#endif



			#define D_UPDATE_TRANS_FIRST 0

			// Apply bump mapping on walls
			#define D_DETAILED_WALLS 0

			// Use to restrict ray marching length. Needed for volumetric evaluation.
			#define D_MAX_STEP_LENGTH_ENABLE 1

			// Light position and color
			#define LPOS vec3( 20.0+15.0*sin(iTime), 15.0+12.0*cos(iTime),-20.0)
			#define LCOL (600.0*vec3( 1.0, 0.9, 0.5))


			float displacementSimple( vec2 p )
			{
				float f;
				f  = 0.5000* textureLod( iChannel0, p, 0.0 ).x; p = p*2.0;
				f += 0.2500* textureLod( iChannel0, p, 0.0 ).x; p = p*2.0;
				f += 0.1250* textureLod( iChannel0, p, 0.0 ).x; p = p*2.0;
				f += 0.0625* textureLod( iChannel0, p, 0.0 ).x; p = p*2.0;
				
				return f;
			}


			vec3 getSceneColor(vec3 p, float material)
			{
				if(material==1.0)
				{
					return vec3(1.0, 0.5, 0.5);
				}
				else if(material==2.0)
				{
					return vec3(0.5, 1.0, 0.5);
				}
				else if(material==3.0)
				{
					return vec3(0.5, 0.5, 1.0);
				}
				
				return vec3(0.0, 0.0, 0.0);
			}


			float getClosestDistance(vec3 p, out float material)
			{
				float d = 0.0;
				#if D_MAX_STEP_LENGTH_ENABLE
					float minD = 1.0; // restrict max step for better scattering evaluation
				#else
					float minD = 10000000.0;
				#endif
					material = 0.0;
					
					float yNoise = 0.0;
					float xNoise = 0.0;
					float zNoise = 0.0;
				#if D_DETAILED_WALLS
					yNoise = 1.0*clamp(displacementSimple(p.xz*0.005),0.0,1.0);
					xNoise = 2.0*clamp(displacementSimple(p.zy*0.005),0.0,1.0);
					zNoise = 0.5*clamp(displacementSimple(p.xy*0.01),0.0,1.0);
				#endif
					
					d = max(0.0, p.y - yNoise);
					if(d<minD)
					{
						minD = d;
						material = 2.0;
					}
					
					d = max(0.0,p.x - xNoise);
					if(d<minD)
					{
						minD = d;
						material = 1.0;
					}
					
					d = max(0.0,40.0-p.x - xNoise);
					if(d<minD)
					{
						minD = d;
						material = 1.0;
					}
					
					d = max(0.0,-p.z - zNoise);
					if(d<minD)
					{
						minD = d;
						material = 3.0;
					}
				
				return minD;
			}


			vec3 calcNormal( in vec3 pos)
			{
				float material = 0.0;
				vec3 eps = vec3(0.3,0.0,0.0);
				return normalize( vec3(
					getClosestDistance(pos+eps.xyy, material) - getClosestDistance(pos-eps.xyy, material),
					getClosestDistance(pos+eps.yxy, material) - getClosestDistance(pos-eps.yxy, material),
					getClosestDistance(pos+eps.yyx, material) - getClosestDistance(pos-eps.yyx, material) ) );

			}

			vec3 evaluateLight(in vec3 pos)
			{
				vec3 lightPos = LPOS;
				vec3 lightCol = LCOL;
				vec3 L = lightPos-pos;
				return lightCol * 1.0/dot(L,L);
			}

			vec3 evaluateLight(in vec3 pos, in vec3 normal)
			{
				vec3 lightPos = LPOS;
				vec3 L = lightPos-pos;
				float distanceToL = length(L);
				vec3 Lnorm = L/distanceToL;
				return max(0.0,dot(normal,Lnorm)) * evaluateLight(pos);
			}

			// To simplify: wavelength independent scattering and extinction
			void getParticipatingMedia(out float sigmaS, out float sigmaE, in vec3 pos)
			{
				float heightFog = 7.0 + D_FOG_NOISE*3.0*clamp(displacementSimple(pos.xz*0.005 + iTime*0.01),0.0,1.0);
				heightFog = 0.3*clamp((heightFog-pos.y)*1.0, 0.0, 1.0);
				
				const float fogFactor = 1.0 + D_STRONG_FOG * 5.0;
				
				const float sphereRadius = 5.0;
				float sphereFog = clamp((sphereRadius-length(pos-vec3(20.0,19.0,-17.0)))/sphereRadius, 0.0,1.0);
				
				const float constantFog = 0.02;

				sigmaS = constantFog + heightFog*fogFactor + sphereFog;
			
				const float sigmaA = 0.0;
				sigmaE = max(0.000000001, sigmaA + sigmaS); // to avoid division by zero extinction
			}

			float phaseFunction()
			{
				return 1.0/(4.0*3.14);
			}

			float volumetricShadow(in vec3 from, in vec3 to)
			{
				#if D_VOLUME_SHADOW_ENABLE
					const float numStep = 16.0; // quality control. Bump to avoid shadow alisaing
					float shadow = 1.0;
					float sigmaS = 0.0;
					float sigmaE = 0.0;
					float dd = length(to-from) / numStep;
					for(float s=0.5; s<(numStep-0.1); s+=1.0)// start at 0.5 to sample at center of integral part
					{
						vec3 pos = from + (to-from)*(s/(numStep));
						getParticipatingMedia(sigmaS, sigmaE, pos);
						shadow *= exp(-sigmaE * dd);
					}
					return shadow;
				#else
					return 1.0;
				#endif
			}

			void traceScene(bool improvedScattering, vec3 rO, vec3 rD, inout vec3 finalPos, inout vec3 normal, inout vec3 albedo, inout vec4 scatTrans)
			{
				const int numIter = 100;
				
				float sigmaS = 0.0;
				float sigmaE = 0.0;
				
				vec3 lightPos = LPOS;
				
				// Initialise volumetric scattering integration (to view)
				float transmittance = 1.0;
				vec3 scatteredLight = vec3(0.0, 0.0, 0.0);
				
				float d = 1.0; // hack: always have a first step of 1 unit to go further
				float material = 0.0;
				vec3 p = vec3(0.0, 0.0, 0.0);
				float dd = 0.0;
				for(int i=0; i<numIter;++i)
				{
					vec3 p = rO + d*rD;
					
					
					getParticipatingMedia(sigmaS, sigmaE, p);
					
			#ifdef D_DEMO_FREE
					if(D_USE_IMPROVE_INTEGRATION>0) // freedom/tweakable version
			#else
					if(improvedScattering)
			#endif
					{
						// See slide 28 at http://www.frostbite.com/2015/08/physically-based-unified-volumetric-rendering-in-frostbite/
						vec3 S = evaluateLight(p) * sigmaS * phaseFunction()* volumetricShadow(p,lightPos);// incoming light
						vec3 Sint = (S - S * exp(-sigmaE * dd)) / sigmaE; // integrate along the current step segment
						scatteredLight += transmittance * Sint; // accumulate and also take into account the transmittance from previous steps

						// Evaluate transmittance to view independentely
						transmittance *= exp(-sigmaE * dd);
					}
					else
					{
						// Basic scatering/transmittance integration
					#if D_UPDATE_TRANS_FIRST
						transmittance *= exp(-sigmaE * dd);
					#endif
						scatteredLight += sigmaS * evaluateLight(p) * phaseFunction() * volumetricShadow(p,lightPos) * transmittance * dd;
					#if !D_UPDATE_TRANS_FIRST
						transmittance *= exp(-sigmaE * dd);
					#endif
					}
					
					
					dd = getClosestDistance(p, material);
					if(dd<0.2)
						break; // give back a lot of performance without too much visual loss
					d += dd;
				}
				
				albedo = getSceneColor(p, material);
				
				finalPos = rO + d*rD;
				
				normal = calcNormal(finalPos);
				
				scatTrans = vec4(scatteredLight, transmittance);
			}


			void main()
			{
				//iTime
				//iMouse
				//iResolution
				vec2 fragCoord = vUv;
				vec2 uv = fragCoord.xy / iResolution.xy;
				
				float hfactor = float(iResolution.y) / float(iResolution.x); // make it screen ratio independent
				vec2 uv2 = vec2(2.0, 2.0*hfactor) * fragCoord.xy / iResolution.xy - vec2(1.0, hfactor);
				
				vec3 camPos = vec3( 20.0, 18.0,-50.0);
				if(iMouse.x+iMouse.y > 0.0) // to handle first loading and see somthing on screen
					camPos += vec3(0.05,0.12,0.0)*(vec3(iMouse.x, iMouse.y, 0.0)-vec3(iResolution.xy*0.5, 0.0));
				vec3 camX   = vec3( 1.0, 0.0, 0.0);
				vec3 camY   = vec3( 0.0, 1.0, 0.0);
				vec3 camZ   = vec3( 0.0, 0.0, 1.0);
				
				vec3 rO = camPos;
				vec3 rD = normalize(uv2.x*camX + uv2.y*camY + camZ);
				vec3 finalPos = rO;
				vec3 albedo = vec3( 0.0, 0.0, 0.0 );
				vec3 normal = vec3( 0.0, 0.0, 0.0 );
				vec4 scatTrans = vec4( 0.0, 0.0, 0.0, 0.0 );
				traceScene( fragCoord.x>(iResolution.x/2.0),
					rO, rD, finalPos, normal, albedo, scatTrans);
				
				
				//lighting
				vec3 color = (albedo/3.14) * evaluateLight(finalPos, normal) * volumetricShadow(finalPos, LPOS);
				// Apply scattering/transmittance
				color = color * scatTrans.w + scatTrans.xyz;
				
				// Gamma correction
				color = pow(color, vec3(1.0/2.2)); // simple linear to gamma, exposure of 1.0
			
			#ifndef D_DEMO_FREE
				// Separation line
				if(abs(fragCoord.x-(iResolution.x*0.5))<0.6)
					color.r = 0.5;
			#endif
				
				gl_FragColor = vec4(color ,1.0);
			}




		`
		const vertexShader = `
			varying vec2 vUv;
			void main(){
				vUv = uv;
				gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
			}
		`
        container = document.getElementById('container');
		var width = window.innerWidth; // 画布的宽度
        var height = window.innerHeight; // 画布的高度
        renderer = new THREE.WebGLRenderer();
        renderer.setSize(width, height);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);
        scene = new THREE.Scene();
          
 
        camera = new THREE.PerspectiveCamera(45, width/height, 1, 2000);;
        camera.position.set(0,0,360);
        scene.add(camera);
 
         
 
        var geometry = new THREE.PlaneBufferGeometry(width, height);
 
        // uniforms = {
        //    iTime: { value: 1.0 },
        //    iResolution: { value: new THREE.Vector2(width * 1.0, height * 1.0)},
        //    iMouse: { value: new THREE.Vector2(0.0, 0.0) }
        // };

		const loader = new THREE.TextureLoader();
		const texture = loader.load('/img/wenli.png');
		texture.minFilter = THREE.NearestFilter;
		texture.magFilter = THREE.NearestFilter;
		texture.wrapS = THREE.RepeatWrapping;
		texture.wrapT = THREE.RepeatWrapping;


		uniforms = {
			iTime:{value:0},
			iResolution:  { value: new THREE.Vector3( 1,1,1) },
			iMouse: { value: new THREE.Vector2(0.0, 0.0) },
			iChannel0: { value: '' },
		};

		
        window.addEventListener("touchmove", function(evt) {
			uniforms.iMouse.x = evt["touches"][0].clientX;
			uniforms.iMouse.y = evt["touches"][0].clientY;
        })
 


        material = new THREE.ShaderMaterial({
			uniforms: uniforms,
			vertexShader: vertexShader,
			fragmentShader: fragmentShader
		});
		// var plane = new THREE.Mesh(new THREE.BoxGeometry(100,100,100), shadertoy);//new THREE.Mesh(planeGeo, shadertoy);
		
		setInterval(()=>{
			uniforms.iTime.value += 0.1;
		},200);

        var geom = new THREE.PlaneBufferGeometry(width, height);
 
        var mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);
 
        var clock = new THREE.Clock(); // 时钟
        (function animate() {
            requestAnimationFrame( animate );
 
            var delta = clock.getDelta(); // 获取本次和上次的时间间隔
            uniforms.iTime.value += delta; // 设置着色器使用的 iTime 参数
            renderer.render( scene, camera ); // 重新渲染
        })();
 
         var mouseStartPosition = null; // 鼠标起始位置

		 // onresize 事件会在窗口被调整大小时发生
		window.onresize=function(){
			// 重置渲染器输出画布canvas尺寸
			renderer.setSize(window.innerWidth,window.innerHeight);
		};

        // window.addEventListener("mousemove", function (event) {
        //     if (!mouseStartPosition) {
        //             mouseStartPosition = {x: event.clientX, y: event.clientY}
        //     } else {
        //             uniforms.iMouse.value.x = event.clientX - mouseStartPosition.x;
        //             uniforms.iMouse.value.y = event.clientY - mouseStartPosition.y;
        // 	}
        // })

	}

	function start() {
		init();
	}

	start();
</script>
</html>